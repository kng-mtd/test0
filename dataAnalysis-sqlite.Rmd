---
title: "Data analysis by SQLite"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    code_folding: show 
---

```{r setup, include=FALSE}
library(DBI)
library(RSQLite)
con = dbConnect(SQLite(), dbname = "knock100.db")
knitr::opts_chunk$set(echo=T,warning=F,message=F,comment='',
                      connection = "con")
```

## see tables and its columns, values
```{sql}
pragma table_list;
```

```{sql}
pragma table_info(receipt);
```
```{sql}
select * from receipt limit 5;
```

```{sql}
pragma table_info(geocode);
```
```{sql}
select * from geocode limit 5;
```

```{sql}
pragma table_info(category);
```
```{sql}
select * from category limit 5;
```

```{sql}
pragma table_info(store);
```
```{sql}
select * from store limit 5;
```

```{sql}
pragma table_info(product);
```
```{sql}
select * from product limit 5;
```

```{sql}
pragma table_info(customer);
```
```{sql}
select * from customer limit 5;
```


## see duplication
```{sql}
select customer_name, postal_cd, count(1) as no
from customer
group by customer_name, postal_cd
having no!=1;
```

```{sql}
with tmp1 as(
  select customer_id, customer_name, postal_cd
    , row_number() over (partition by customer_name, postal_cd order by customer_id) as no
  from customer
)
select * from tmp1 where no!=1;
```


## process to null
```{r}
dbExecute(con,
          "create temp table tmp1 (chr1 text, num1 int, num2 int, num3 int)")
sql0="insert into tmp1 (chr1, num1, num2, num3) values "
sql=paste0(sql0,"('a',0,10,100)")
dbExecute(con,sql)
sql=paste0(sql0,"('a',1,20,200)")
dbExecute(con,sql)
sql=paste0(sql0,"('b',null,30,300)")
dbExecute(con,sql)
sql=paste0(sql0,"('b',3,null,400)")
dbExecute(con,sql)
sql=paste0(sql0,"('b',4,40,500)")
dbExecute(con,sql)
```
```{sql}
select * from tmp1;
```

### don't count null
```{sql}
select count(1), count(chr1), count(num1), count(num2), count(num3)
  , sum(chr1), sum(num1), sum(num2), sum(num3)
  , avg(chr1), avg(num1), avg(num2), avg(num3) from tmp1;
```

### rows have null
answer of alithmetic  includes null is null,  
text type column's value is 0 when its used alithmetic
```{sql}
select * from tmp1
  where chr1+num1+num2 is null;
```

### groups have null in specified column
```{sql}
select chr1 from tmp1
group by chr1
having count(1)!=count(num1);
```

```{sql}
drop table tmp1;
```


## aggregation

```{sql}
with tmp1 as(
  select store_cd, count(1) as n, sum(amount) as sum
    , min(amount-0) as min, max(amount-0) as max
    , median(amount) as med
    , avg(amount) as mean, avg(amount*amount) as sq
  from receipt
  group by store_cd
)
select store_cd, n,sum, min, max, med, mean
  , sqrt(sq-mean*mean) as sd
  , sqrt(sq-mean*mean)/mean as cv
from tmp1;
```


```{sql}
with tmp1 as(
  select store_cd, count(1) as n from receipt group by store_cd
)
, tmp2 as(
  select store_cd, amount, amount*amount as sq, n
    , row_number() over(partition by store_cd order by amount-0) as rank
    from receipt
  inner join tmp1 using(store_cd)
)
select store_cd, n, sum(amount) as sum
  , min(amount-0) as min
  , max(case when rank=round(n*0.25) then amount else 0 end) as q1
  , max(case when rank=round(n*0.5) then amount else 0 end) as q2 
  , max(case when rank=round(n*0.75) then amount else 0 end) as q3
  , max(amount-0) as max
  , avg(amount) as mean
  , sqrt(avg(sq)-avg(amount)*avg(amount)) as sd
  , sqrt(avg(sq)-avg(amount)*avg(amount))/avg(amount) as cv
from tmp2
group by store_cd;
```


## see difference
```{sql}
create temp table tmp0 as
  with tmp1 as(
    select count(1) as n0, avg(age) as mean0
      , sqrt(avg(age*age)) as sd0 from customer
  )
  , tmp2 as(
    select count(1) as na, avg(age) as mean_a
      , sqrt(avg(age*age)) as sd_a from customer
    where gender_cd='0'
  )
  , tmp3 as(
    select count(1) as nb, avg(age) as mean_b
      , sqrt(avg(age*age)) as sd_b from customer
    where gender_cd='1' 
  )
  select n0, mean0, sd0, na, mean_a, sd_a, nb, mean_b, sd_b
  from tmp1, tmp2, tmp3;
```

#### Glass's delta
```{sql}
select (mean_a-mean0)/sd0 as G_delta from tmp0;
```

#### Cohen's d
```{sql}
select (mean_a-mean_b)/sqrt(((na-1)*sd_a*sd_a+(nb-1)*sd_b*sd_b)/(na+nb-2)) as d
from tmp0;
```

```{sql}
drop table tmp0;
```


## make dummy var. from category var.

```{sql}
select customer_id
  , max(case when gender_cd='0' then 1 else 0 end) as male
  , max(case when gender_cd='1' then 1 else 0 end) as female
  , max(case when gender_cd='9' then 1 else 0 end) as unknown
from customer
group by customer_id;
```


## invalid date value(YYYYmmdd) is made to null

```{sql}
select '20000123' as str
  , date(substr('20000123',1,4)||'-'||
    substr('20000123',5,2)||'-'||
    substr('20000123',7,2)) as date;
```

```{sql}
select '20001234' as str
  , date(substr('200001234',1,4)||'-'||
    substr('20001234',5,2)||'-'||
    substr('20001234',7,2)) as date;
```

```{sql}
select sales_ymd
  , date(substr(sales_ymd,1,4)||'-'||
    substr(sales_ymd,5,2)||'-'||
    substr(sales_ymd,7,2)) as date
from receipt;
```


## invalid time value(HHMMSS) is made to null

```{sql}
select '123456' as str
  , time(substr('123456',1,2)||':'||
    substr('123456',3,2)||':'||
    substr('123456',5,2)) as time;
```

```{sql}
select '234567' as str
  , time(substr('234567',1,2)||':'||
    substr('234567',3,2)||':'||
    substr('234567',5,2)) as time;
```


## interval of date

```{sql}
select customer_id, birth_day, apply
  , julianday(apply)-julianday(birth_day) as days
  , strftime('%Y',julianday(apply))-strftime('%Y',julianday(birth_day))-0 as years
from(
  select customer_id, birth_day
    , date(substr(application_date,1,4)||'-'||
      substr(application_date,5,2)||'-'||
      substr(application_date,7,2)) as apply
  from customer);
```


## add row has 0 instead of no row in time series

```{sql}
select customer_id
  , row_number() over(partition by customer_id order by sales_ymd) as times
from receipt
where customer_id not like 'Z%'
order by times desc;
```

```{sql}
with tmp1 as(
  select distinct strftime('%Y%m',date(sales_epoch,'unixepoch')) as ym
  from receipt
)
select ym, coalesce(sum,0) from tmp1 left join(
  select strftime('%Y%m',date(sales_epoch,'unixepoch')) as ym
    , sum(amount) as sum
  from receipt where customer_id='CS040214000008'
  group by ym
) using(ym)
order by ym;
```


## standardization, normalization

```{sql}
with tmp1 as(
  select sales_ymd, sum(quantity) as qty, sum(amount) as amt
  from receipt group by sales_ymd
)
, tmp2 as(
  select avg(qty) as q_mean, avg(qty*qty) q_sq
    , min(qty) as q_min, max(qty) as q_max
    , avg(amt) as a_mean, avg(amt*amt) a_sq
    , min(amt) as a_min, max(amt) as a_max
  from tmp1
)
select sales_ymd
  , (qty-q_mean)/sqrt(q_sq-q_mean*q_mean) as q_z
  , (qty-q_min-0.0)/(q_max-q_min) as q_0to1
  , (amt-a_mean)/sqrt(a_sq-a_mean*a_mean) as a_z
  , (amt-a_min-0.0)/(a_max-a_min) as a_0to1
from tmp1,tmp2;

```


## difference to previous period, rate to previous period

```{sql}
with tmp1 as(
  select sales_ymd, sum(quantity) as qty, sum(amount) as amt
  from receipt group by sales_ymd
)
, tmp2 as(
  select sales_ymd
    , qty, lag(qty,1) over(order by sales_ymd) as qty_lag1
    , lag(qty,2) over(order by sales_ymd) as qty_lag2
    , amt, lag(amt,1) over(order by sales_ymd) as amt_lag1
    , lag(amt,2) over(order by sales_ymd) as amt_lag2
  from tmp1
)
select sales_ymd, qty, qty_lag1
  , qty-qty_lag1 as q_diff1, qty*1.0/qty_lag1 as q_rate1, qty_lag2
  , amt, amt_lag1
  , amt-amt_lag1 as a_diff1, amt*1.0/amt_lag1 as a_rate1, amt_lag2
from tmp2;
```


## cumulative sum, moving average

```{sql}
with tmp1 as(
  select sales_ymd, sum(quantity) as qty, sum(amount) as amt
  from receipt group by sales_ymd
)
select sales_ymd
  , qty, sum(qty) over(order by sales_ymd) as cum_qty
  , avg(qty) over(order by sales_ymd) as cum_avg_qty
  , avg(qty) over(order by sales_ymd rows between 2 preceding and current row) as mov_avg_qty
  , amt, sum(amt) over(order by sales_ymd) as cum_amt
  , avg(amt) over(order by sales_ymd) as cum_avg_amt
  , avg(amt) over(order by sales_ymd rows between 2 preceding and current row) as mov_avg_amt
from tmp1;
```


## node and edge graph

```{sql}
create temp table edges0 as
  with recursive tmp1 as (
      select 1 as num
      union all
      select num+1 from tmp1 where num<300
  )
  select abs(random())%10+1 as org, abs(random())%10+1 as dst from tmp1;
```

```{sql}
create temp table edges as
  select * from edges0 where org!=dst;
```

```{sql}
select * from edges;
```

```{sql}
with tmp1 as(
  select org, count(1) as out_deg from edges group by org
)
, tmp2 as(
  select dst, count(1) as in_deg from edges group by dst
)
, tmp3 as(
  select org, dst, count(1) as weight from edges group by org,dst
)
select org, dst, weight, out_deg, weight*1.0/out_deg as out_prop
  , in_deg, weight*1.0/in_deg as in_prop
from tmp3
inner join tmp1 using(org)
inner join tmp2 using(dst);
```

```{sql}
drop table edges;
```

```{sql}
create temp table edges as
  select case when org<dst then org else dst end as node1
    , case when org>dst then org else dst end as node2
  from edges0
```

```{sql}
select * from edges;
```

```{sql}
with tmp1 as(
  select node1, count(1) as deg1 from edges group by node1
)
, tmp2 as(
  select node2, count(1) as deg2 from edges group by node2
)
, tmp3 as(
  select node1, node2, count(1) as weight from edges group by node1, node2
)
select node1, node2, weight, deg1+deg2, weight*1.0/(deg1+deg2) as prop
from tmp3
inner join tmp1 using(node1)
inner join tmp2 using(node2);
```

```{sql}
drop table edges;
```

```{sql}
drop table edges0;
```


## basket analysis, collaborative filtering

```{sql}
create temp table basket0 as
  with recursive tmp1 as (
      select 1 as num
      union all
      select num+1 from tmp1 where num<100
  )
  select abs(random())%10+1 as grp, abs(random())%20+1 as item from tmp1;
```

#### It does not has order
```{sql}
create temp table basket as
  with tmp1 as(
    select grp, item
    from basket0
  )
  , tmp2 as(
    select t1.grp as grp, t1.item as item1, t2.item as item2
    from tmp1 as t1
    inner join tmp1 as t2 on t1.grp=t2.grp and t1.item<t2.item
    group by t1.grp, item1, item2
  )
  select grp, item1, item2 from tmp2;
```

```{sql}
select * from basket order by grp;
```

```{sql}
select item1, item2, count(1) as frq from basket group by item1, item2
order by item1, item2; 
```

```{sql}
drop table basket;
```


#### It has order, make trigram
```{sql}
create temp table basket as
  with tmp1 as(
    select distinct grp, item from basket0
  )
  select grp, item
    , row_number() over(partition by grp order by random()) as ord
  from tmp1
```

```{sql}
select grp, ord
  , lag(item,1) over(partition by grp) as before
  , item
  , lead(item,1) over(partition by grp) as after
from basket;
```

```{sql}
drop table basket;
```

```{sql}
drop table basket0;
```


## process of categorical variable

```{sql}
select gender_cd, count(1), count(1)*1.0/max(rowid) as proportion
from customer group by gender_cd;
```

```{sql}
select gender_cd, age/10*10 as ages, count(1)
from customer group by gender_cd, ages;
```

```{sql}
select customer_id, gender_cd
  , case when age-0<20 then 1 else 0 end young
  , case when age-0 between 20 and 64 then 1 else 0 end adult
  , case when age-0>64 then 1 else 0 end senior
from customer limit 10;
```


```{sql}
create temp table cross as
  with tmp1 as(
    select gender_cd
    , sum(case when age-0<20 then 1 else 0 end) young
    , sum(case when age-0 between 20 and 64 then 1 else 0 end) adult
    , sum(case when age-0>64 then 1 else 0 end) senior
    , count(1) subtotal
    from customer group by gender_cd
  )
  select * from tmp1
```

```{sql}
select * from cross
union all
select 'subtotal', sum(young), sum(adult), sum(senior), sum(subtotal)
from cross;
```

```{sql}
select gender_cd
  , young*1.0/subtotal as prop_young
  , adult*1.0/subtotal as prop_adult
  , senior*1.0/subtotal as prop_senior
from cross
union all
select 'total'
  , sum(young)*1.0/sum(subtotal)
  , sum(adult)*1.0/sum(subtotal)
  , sum(senior)*1.0/sum(subtotal)
from cross;
```
```{sql}
with tmp1 as(
  select 'proportion'
  , sum(young)*1.0/sum(subtotal) as prop_young
  , sum(adult)*1.0/sum(subtotal) as prop_adult
  , sum(senior)*1.0/sum(subtotal) as prop_senior
  from cross
)
select gender_cd
  , young*1.0/subtotal/tmp1.prop_young as lift_young
  , adult*1.0/subtotal/tmp1.prop_adult as lift_adult
  , senior*1.0/subtotal/tmp1.prop_senior as lift_senior
from cross,tmp1;
```

```{sql}
drop table cross;
```


## histgram on Sturges' rule

```{sql}
with tmp1 as(
 select ceil(log(count(1)/log(2))+1) as k, min(amount-0) as min, max(amount-0) as max
 from receipt
)
select bin, min(amount-0) as left, max(amount-0) as right, count(1) from(
 select amount, round((amount-min-0.0)/(max-min)* k ) as bin from receipt, tmp1)
group by bin order by bin;
```


## correlation
```{sql}
with tmp1 as(
  select store_cd, floor_area as area, sum(amount) as amount
  from store left join receipt using(store_cd)
  group by store_cd, area
)
select (count(1)*sum(area*amount)-sum(area)*sum(amount))/
  sqrt(count(1)*sum(area*area)-sum(area)*sum(area))/
  sqrt(count(1)*sum(amount*amount)-sum(amount)*sum(amount)) as corr
from tmp1;
```


## sampling
#### extract a certain number
```{sql}
select row_number() over() as id,* from(
  select customer_id, gender_cd, age from customer
  where customer_id not like 'Z%'
  order by random() limit 10
)
```

#### stratify and extract a certain number
```{sql}
select row_number() over() as id,* from(
  select customer_id, gender_cd, age from customer
  where customer_id not like 'Z%' and gender_cd='0'
  order by random() limit 10
)
union all
select row_number() over() as id,* from(
  select customer_id, gender_cd, age from customer
  where customer_id not like 'Z%' and gender_cd='1'
  order by random() limit 10
)
```

#### divide data to learn or test with 8:2 for ML
```{sql}
select row_number() over() as id, customer_id
  , case when abs(random())%10<8 then 'learn' else 'test' end as grp
from customer
where customer_id not like 'Z%';
```

#### divide to 2 groups 
```{sql}
select row_number() over() as id, customer_id, gender_cd, age
  , case when abs(random())%2<1 then 'A' else 'B' end as grp
from customer
where customer_id not like 'Z%';
```

#### divide to 4 groups 
```{sql}
create temp table tmp1 as
  select row_number() over() as id, customer_id, gender_cd, age
    , case when abs(random())%4<1 then 'A'
      when abs(random())%3<1 then 'B'
      when abs(random())%2<1 then 'C' else 'D' end as grp
  from customer
  where customer_id not like 'Z%';
```

```{sql}
select grp, gender_cd, count(1), avg(age) from tmp1 group by grp, gender_cd;
```

```{sql}
drop table tmp1
```
